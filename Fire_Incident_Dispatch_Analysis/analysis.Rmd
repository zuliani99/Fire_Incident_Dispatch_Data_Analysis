---
title: "Fire Incident Dispatch Data Analysis"
author: "Zuliani Riccardo"
date: "12/12/2023"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE) #, cache=TRUE
setwd("C:/Users/ricca/Desktop/UNI/Magistrale/Anno3/Statistical_Inference_and_Learning/SIL Projcet/Statistical_Inference_Learning_Project/Fire_Incident_Dispatch_Analysis")

#install.packages("nnet")
#install.packages("jmv")
#install.packages("summarytools")

library(nnet)
#library(jmv)
library(summarytools)
library(lubridate)
#library(ggplot2)
```

# Fire Incident Dispatch Data Analysis
Read the restricted dataset of last 50k observation form the original 10.000.000 observations dataset



```{r}
#last_50000 <- tail(read.csv("Fire_Incident_Dispatch_Data.csv"), 50000)

#write.csv(last_50000, file = "C:/Users/ricca/Desktop/UNI/Magistrale/Anno3/Statistical_Inference_and_Learning/SIL Projcet/Statistical_Inference_Learning_Project/Fire_Incident_Dispatch_Analysis/Fire_Incident_Dispatch_Data_last.csv", row.names = FALSE)
```



```{r read_data, cache=TRUE}
fire_data <- read.csv("datases/Fire_Incident_Dispatch_Data_last_50k.csv")

head(fire_data)
```

```{r}
print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```


## Check column before deleting them

```{r}
identical(fire_data$ALARM_BOX_BOROUGH, fire_data$INCIDENT_BOROUGH)
```
The column ALARM_BOX_BOROUGH and INCIDENT_BOROUGH have the same sequence of values, so we can delete one of the two

```{r}
fire_data$VALID_DISPATCH_RSPNS_TIME_INDC <- as.factor(fire_data$VALID_DISPATCH_RSPNS_TIME_INDC)
summary(fire_data$VALID_DISPATCH_RSPNS_TIME_IND)
```
All our observations have non valid VALID_DISPATCH_RSPNS_TIME_IND so we can delete both the column indicator and the respective column quantity



```{r}
fire_data$VALID_INCIDENT_RSPNS_TIME_INDC <- as.factor(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
summary(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
```
Whereas here we have some observations with valid VALID_INCIDENT_RSPNS_TIME_INDC, we will delete the one that has a non valid attribute



Let's set some factorials
```{r}
fire_data$INCIDENT_BOROUGH <- as.factor(fire_data$INCIDENT_BOROUGH)
fire_data$ALARM_SOURCE_DESCRIPTION_TX <- as.factor(fire_data$ALARM_SOURCE_DESCRIPTION_TX)
fire_data$ALARM_LEVEL_INDEX_DESCRIPTION <- as.factor(fire_data$ALARM_LEVEL_INDEX_DESCRIPTION)
fire_data$HIGHEST_ALARM_LEVEL <- as.factor(fire_data$HIGHEST_ALARM_LEVEL)

fire_data$VALID_INCIDENT_RSPNS_TIME_INDC <- as.factor(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
levels(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)<- c("N", "Y")

fire_data$INCIDENT_CLASSIFICATION_GROUP <- as.factor(fire_data$INCIDENT_CLASSIFICATION_GROUP)
fire_data$INCIDENT_CLASSIFICATION <- as.factor(fire_data$INCIDENT_CLASSIFICATION)

# ALARM_BOX_LOCATION is a little bit difficult to model it is better to focus in the big area
```



Now we want to know how many INCIDENT_CLASSIFICATION class are summarized in each INCIDENT_CLASSIFICATION_GROUP
```{r}
print(ctable(fire_data$INCIDENT_CLASSIFICATION, fire_data$INCIDENT_CLASSIFICATION_GROUP), method = 'render')
```
As we can see from the upper table all the INCIDENT_CLASSIFICATION_GROUP have a unique set of INCIDENT_CLASSIFICATION 

At this point to be more clear we display each main class with each respective sub-class and then we meke a little description.

```{r}
for (variable in levels(fire_data$INCIDENT_CLASSIFICATION_GROUP)) {
  non_zero_table <- table(subset(fire_data, INCIDENT_CLASSIFICATION_GROUP == variable)$INCIDENT_CLASSIFICATION)
  cat(variable, "\n")
  print(non_zero_table[non_zero_table != 0])
  cat("\n")
}

```



**Medical Emergency**:
1. *Medical - Assist Civilian*




## See if there is a pattern with the NA/invaid values

First of all we check if the distribution of invalid VALID_INCIDENT_RSPNS_TIME_INDC is more or less uniform across all the neighborhoods
```{r}
summary(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
```

```{r}
table(fire_data$INCIDENT_BOROUGH)
```

```{r}
non_valid_inc_resp <- subset(fire_data, VALID_INCIDENT_RSPNS_TIME_INDC == "N")
table(non_valid_inc_resp$INCIDENT_BOROUGH)
```

```{r}
table(non_valid_inc_resp$INCIDENT_BOROUGH) / table(fire_data$INCIDENT_BOROUGH)
```

More or less all the neighborhoods have the same distribution of invalid valid_inc_resp_time_indc


Now we want to check some other aspects of the data, for example the NA values of the DISTRICT columns, let's summarize the data again

```{r}
summary(fire_data)
```

```{r}
na_locations <- subset(fire_data, is.na(ZIPCODE) | is.na(POLICEPRECINCT) | is.na(CITYCOUNCILDISTRICT) | is.na(COMMUNITYDISTRICT) |  is.na(COMMUNITYSCHOOLDISTRICT) |  is.na(CONGRESSIONALDISTRICT))
print(dfSummary(na_locations, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```

```{r}
table(na_locations$INCIDENT_BOROUGH) / table(fire_data$INCIDENT_BOROUGH)
```

```{r}
table(na_locations$INCIDENT_CLASSIFICATION_GROUP) / table(fire_data$INCIDENT_CLASSIFICATION_GROUP)
```

This is interesting, we see that about the 43% of the NonMedical MFAs INCIDENT_CLASSIFICATION_GROUP are NA whereas the other classes have lower percentage. We can try to investigate this phenomena.


```{r}
fd_nm_mfa_cl <- table(subset(fire_data, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_CLASSIFICATION)
fd_nm_mfa_bro <- table(subset(fire_data, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_BOROUGH)

fd_nm_mfa_cl <- fd_nm_mfa_cl[fd_nm_mfa_cl != 0]
fd_nm_mfa_cl
```


```{r}
na_nm_mfa_cl <- table(subset(na_locations, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_CLASSIFICATION)
na_nm_mfa_bro <- table(subset(na_locations, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_BOROUGH)

na_nm_mfa_cl <- na_nm_mfa_cl[names(fd_nm_mfa_cl)]
na_nm_mfa_cl
```
Here we can see that the majority of observation that at least one location attributes to NA have a response equal to Non-Medical MFA - ERS



```{r}
na_nm_mfa_cl / fd_nm_mfa_cl
```
So the 97% of all the Non-Medical MFA - ERS observations in the entire dataset have one of the location attribute equal to NA

```{r}
na_nm_mfa_bro / fd_nm_mfa_bro
```
And from here we can see that about the 78% of the observations that are NonMedical - MFAs that have at least one district column attribute to NA are from the RICHMOND / STATEN ISLAND.
Also BRONX has about half of the NonMedical - MFAs observations that have at least one district column to NA.




```{r}
print(summary(subset(fire_data, VALID_INCIDENT_RSPNS_TIME_INDC == "N")$INCIDENT_RESPONSE_SECONDS_QY))
print(summary(fire_data$INCIDENT_RESPONSE_SECONDS_QY))
```
Here we can see that all the observation NA observation to the INCIDENT_RESPONSE_SECONDS_QY has the respective VALID_INCIDENT_RSPNS_TIME_INDC value to N



## Removing all the NA and unuseful columns from the dataset

Remove some columns
```{r}
fire_data = subset(fire_data, select = -c(
  STARFIRE_INCIDENT_ID, ALARM_BOX_BOROUGH, INCIDENT_CLASSIFICATION, ALARM_BOX_LOCATION,
  VALID_DISPATCH_RSPNS_TIME_INDC, DISPATCH_RESPONSE_SECONDS_QY, 
  FIRST_ASSIGNMENT_DATETIME, FIRST_ACTIVATION_DATETIME, FIRST_ON_SCENE_DATETIME, INCIDENT_CLOSE_DATETIME 
))
```


Rename all the columns with a shorter and usable name
```{r}
names(fire_data) <- c("fire_datetime", "AL_loction", "incident_brough", "zip", "Pprecint", "citycouncil_dist", "community_dist", "comm_school_dist", "congressional_dist", "alarm_source_desc", "alarm_level_idx", "highest_alarm_lev", "incident_class", "valid_inc_resp_time_indc", "incident_resp_sec", "incident_travel_time_sec", "engines_assigned", "ladders_assigned", "other_utits_assigned")
names(fire_data)
```

```{r}
# Select the observations with the valid_inc_resp_time_indc set to Y
fire_data <- subset(fire_data, valid_inc_resp_time_indc == "Y")

fire_data <- na.omit(fire_data)

print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```

Remove the VALID_INCIDENT_RSPNS_TIME_INDC column
```{r}
fire_data = subset(fire_data, select = -c(valid_inc_resp_time_indc))
```



## Merging factor

```{r}
# highest_alarm_lev
fire_data$highest_alarm_lev_new <- fire_data$highest_alarm_lev
levels(fire_data$highest_alarm_lev_new) <- list(
  "All Hands Working" = "All Hands Working",
  "First Alarm" = "First Alarm", 
  "2nd-3rd Alarm" = c("Second Alarm", "Third Alarm")
)

print(ctable(fire_data$highest_alarm_lev, fire_data$highest_alarm_lev_new), method = 'render')

fire_data$highest_alarm_lev <- fire_data$highest_alarm_lev_new
fire_data$highest_alarm_lev_new <- NULL
```

```{r}
# alarm_level_idx
fire_data$alarm_level_idx_new <- fire_data$alarm_level_idx
levels(fire_data$alarm_level_idx_new) <- list(
  "DEFAULT RECORD" = "DEFAULT RECORD",
  "Initial Alarm" = "Initial Alarm", 
  "Others" = c("Second Alarm", "Third Alarm", "7-5 (All Hands Alarm)", 
               "10-76 & 10-77 Signal (Notification Hi-Rise Fire)",
               "10-75 Signal (Request for all hands alarm)")
)

print(ctable(fire_data$alarm_level_idx, fire_data$alarm_level_idx_new), method = 'render')

fire_data$alarm_level_idx <- fire_data$alarm_level_idx_new
fire_data$alarm_level_idx_new <- NULL
```


```{r}
# alarm_source_desc
fire_data$alarm_source_desc_new <- fire_data$alarm_source_desc
levels(fire_data$alarm_source_desc_new) <- list(
  "PHONE" = "PHONE",
  "EMS" = "EMS",
  "EMS-911" = "EMS-911",
  "CLASS-3" = "CLASS-3",
  "Others" = c("911", "911TEXT", "VERBAL", "BARS", "ERS", "ERS-NC", "SOL")
)

print(ctable(fire_data$alarm_source_desc, fire_data$alarm_source_desc_new), method = 'render')

fire_data$alarm_source_desc <- fire_data$alarm_source_desc_new
fire_data$alarm_source_desc_new <- NULL
```

Check the distribution of the classes
```{r}
round(summary(fire_data$incident_class) / nrow(fire_data), digits = 4)
```


## Process datetime
Here we extract the date number and the moment in which the fire happened divided into "Night", "Morning", "Afternoon" and "Evening"

```{r}
process_fire_datetime <- function(input_df) {

  # Process datetime column
  input_df$fire_datetime <- mdy_hms(input_df$fire_datetime)
  
  # Create new columns for day number and time of day
  input_df$day_number <- as.factor(day(input_df$fire_datetime))
  input_df$time_of_day <- cut(
    hour(input_df$fire_datetime),
    breaks = c(0, 6, 12, 18, 24),
    labels = c("Night", "Morning", "Afternoon", "Evening"),
    include.lowest = TRUE,
    right = TRUE
  )
  
  input_df$fire_datetime <- NULL
  
  return(input_df)
}

fire_data_new <- process_fire_datetime(fire_data)

print(dfSummary(fire_data_new, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```


## Train test split
```{r}
sample <- sample(c(TRUE, FALSE), nrow(fire_data_new), replace=TRUE, prob=c(0.8,0.2))
fire_data.train <- fire_data_new[sample, ]
fire_data.test <- fire_data_new[!sample, ]
#fire_data.test <- subset(fire_data.test, select = -incident_class)
dim(fire_data.train)
dim(fire_data.test)
```



Check the distribution of the class in the train set
```{r}
round(summary(fire_data.train$incident_class) / nrow(fire_data.train), digits = 4)
```






## TODO
1. Know the meaning of the incident class -> fatto basta guardare la tabella riassuntiva
2. View if there are some relation within the missing data -> faccio questo domani
3. Start to plot some data to see some relation between some data

## Check if solving the problem as a classification task wrt each main class so 
1. structural and non-structural fire
2. medical and non-medical emergency
3. medical and non-medical MFAs


# Molutinomial Logistic Regression
```{r}
pValue_extract <- function(x){
  z <- summary(x)$coefficients/summary(x)$standard.errors
  # 2-tailed Wald z tests to test significance of coefficients
  p <- (1 - pnorm(abs(z), 0, 1)) * 2
  p
}
```


```{r}
multi.fit1 <- multinom(incident_class ~ ., data = fire_data.train, trace = FALSE)
```

```{r}
table(preds = multi.preds1 <- predict(multi.fit1, newdata = fire_data.test), true = fire_data.test$incident_class)
```

```{r}
multi.fit1$AIC
```
```{r}
mean(multi.preds1 == fire_data.test$incident_class)
```

```{r}
#pValue_extract(multi.fit1)
```




Try a new model with less predictors
```{r}
multi.fit2 <- update(multi.fit1, . ~ . - AL_loction - zip - Pprecint - citycouncil_dist - community_dist - comm_school_dist - congressional_dist - day_number)
multi.fit2$AIC
```

```{r}
table(preds = multi.preds2 <- predict(multi.fit2, newdata = fire_data.test), true = fire_data.test$incident_class)
```


```{r}
mean(multi.preds2 == fire_data.test$incident_class)
```

```{r}
summary(multi.fit2, wald = TRUE)
```

```{r}
#pValue_extract(multi.fit2)
```


## Linear Discriminant Analysis
Now consider linear discriminant analysis:
```{r}
library("MASS")
lda.fit <- lda(formula(multi.fit2), data = fire_data.train)
lda.fit
```
Prediction:
```{r}
lda.preds <- predict(lda.fit, newdata = fire_data.test)
``` 

```{r}
table(preds = lda.preds$class, true = fire_data.test$incident_class)
```
The accuracy of linear discriminant analysis is worse respect to the multinomial logistic regression:
```{r}
mean(lda.preds$class == fire_data.test$incident_class)
```


Now consider quadratic discriminant analysis:



## Naive Bayes
```{r}
library("e1071")
nb.fit <- naiveBayes(formula(multi.fit2), data = fire_data.train)
```
Prediction:
```{r}
nb.preds <- predict(nb.fit, newdata = fire_data.test, type = "class")
``` 

```{r}
table(preds = nb.preds, true = fire_data.test$incident_class)
```
The accuracy of linear discriminant analysis is worse respect to the multinomial logistic regression:
```{r}
mean(nb.preds == fire_data.test$incident_class)
```

## K-Nearest Neighbours
```{r}
x.train <- model.matrix(~ incident_brough + alarm_source_desc + alarm_level_idx + 
    highest_alarm_lev + incident_resp_sec + incident_travel_time_sec + 
    engines_assigned + ladders_assigned + other_utits_assigned + 
    time_of_day, data = fire_data.train)[, -1]
x.test <- model.matrix(~ incident_brough + alarm_source_desc + alarm_level_idx + 
    highest_alarm_lev + incident_resp_sec + incident_travel_time_sec + 
    engines_assigned + ladders_assigned + other_utits_assigned + 
    time_of_day, data = fire_data.test)[, -1]
library("class")
set.seed(98765)
rates <- double(30)
for (i in 1:30) {
  tmp <- knn(train = x.train, test = x.test, cl = fire_data.train$incident_class, k = i)
  rates[i] <- mean(tmp == fire_data.test$incident_class)
}
plot(x = (1:30), y = rates, xlab = "k", ylab = "Accuracy", type = "l")
```

