---
title: "Fire Incident Dispatch Data Analysis"
author: "Zuliani Riccardo"
date: "12/12/2023"
output: 
  html_document: 
    toc: true
    toc_float: true
    number_sections: true
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE) #, cache=TRUE
setwd("C:/Users/ricca/Desktop/UNI/Magistrale/Anno3/Statistical_Inference_and_Learning/SIL Projcet/Statistical_Inference_Learning_Project/Fire_Incident_Dispatch_Analysis")
```

# Loads & Install Packages

```{r}
if (!require("nnet")) install.packages("nnet")
if (!require("summarytools")) install.packages("summarytools")
if (!require("dplyr")) install.packages("dplyr")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("lubridate")) install.packages("lubridate")
if (!require("mapview")) install.packages("mapview")
if (!require("sf")) install.packages("sf")
if (!require("geojsonio")) install.packages("geojsonio")
if (!require("leaflet")) install.packages("leaflet")
if (!require("broom")) install.packages("broom")
if (!require("plotly")) install.packages("plotly")

library(nnet)
library(summarytools)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(mapview)
library(sf)
library(geojsonio)
library(leaflet) 
library(broom)
library(plotly)
```


# Dataset description

The Fire Incident Dispatch Data file contains data that is generated by the Starfire Computer Aided Dispatch System. The data spans from the time the incident is created in the system to the time the incident is closed in the system. It covers information about the incident as it relates to the assignment of resources and the Fire Departmentâ€™s response to the emergency. To protect personal identifying information in accordance with the Health Insurance Portability and Accountability Act (HIPAA), specific locations of incidents are not included and have been aggregated to a higher level of detail.

In this analysis we have restricted the analysis only on the *last 50.000 observations*.

1. **STARFIRE_INCIDENT_ID**: An incident identifier comprising the 5 character julian date, 4 character alarm box number, 2 character number of incidents at the box so far for the day, 1 character borough code , 4 character sequence number. 
2. **INCIDENT_DATETIME**: The date and time of the incident.
3. **ALARM_BOX_BOROUGH**: The borough of the alarm box.
4. **ALARM_BOX_LOCATION**: The location of the alarm box.
5. **ALARM_BOX**: The alarm box number.
6. **INCIDENT_BOROUGH**: The borough of the incident.
7. **ZIPCODE**: The zip code of the incident.
8. **POLICEPRECINCT**: The police precinct of the incident.
9. **CITYCOUNCILDISTRICT**: The city council district.
10. **COMMUNITYDISTRICT**: The community district.
11. **COMMUNITYSCHOOLDISTRICT**: The community school district.
12. **CONGRESSIONALDISTRICT**: The congressional district.
13. **ALARM_SOURCE_DESCRIPTION_TX**: The description of the alarm source.
14. **ALARM_LEVEL_INDEX_DESCRIPTION**: The alarm level index.
15. **HIGHEST_ALARM_LEVEL**: The highest alarm level.
16. **INCIDENT_CLASSIFICATION**: The incident classification.
17. **INCIDENT_CLASSIFICATION_GROUP**: The incident classification roll up group. (*response*)
18. **DISPATCH_RESPONSE_SECONDS_QY**: The elapsed time in seconds between the incident_datetime and the first_assignment_datetime.
19. **FIRST_ASSIGNMENT_DATETIME**: The date and time of the first unit assignment.
20. **FIRST_ACTIVATION_DATETIME**: The date and time of the first unit acknowledgement of the assignment.
21. **FIRST_ON_SCENE_DATETIME**: The date and time of the first unit at the scene of the incident.
22. **INCIDENT_CLOSE_DATETIME**: The date and time that the incident was closed in the dispatch system.
23. **VALID_DISPATCH_RSPNS_TIME_INDC**: Indicates that the components comprising the generation of the DISPATCH_RESPONSE_SECONDS_QY are valid.
24. **VALID_INCIDENT_RSPNS_TIME_INDC**: Indicates that the components comprising the generation of the INCIDENT_RESPONSE_SECONDS_QY are valid.
25. **INCIDENT_RESPONSE_SECONDS_QY**: The elapsed time in seconds between the incident_datetime and the first_onscene_datetime.
26. **INCIDENT_TRAVEL_TM_SECONDS_QY**: The elapsed time in seconds between the first_assignment_datetime and the first_onscene_datetime.
27. **ENGINES_ASSIGNED_QUANTITY**: The number of engine units assigned to the incident.
28. **LADDERS_ASSIGNED_QUANTITY**: The number of ladder units assigned to the incident.
29. **OTHER_UNITS_ASSIGNED_QUANTITY**: The number of  units that are not engines or ladders that were assigned to the incident.

For this analysis we use as response the **INCIDENT_CLASSIFICATION_GROUP** which contain the main grups of incidents. They are the following one:

1. **Structural Fires**
2. **NonStructural Fires**
3. **NonMedical Emergencies**
4. **NonMedical MFAs**
5. **Medical Emergencies**
6. **Medical MFAs**


# Data Exlporation and Cleaning

The first step is always to read the dataset and plot the first 5 observations
```{r, cache=TRUE}
fire_data <- read.csv("datasets/Fire_Incident_Dispatch_Data_last_50k.csv")

head(fire_data)
```

Use `dfSummary` from summarytool in order to have a complete and clear sumamry of the dataset.
```{r}
print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.75),
                method = 'render')
```

Now we rename all the columns in order to be smaller whenever we plot graphs.
```{r}
fire_data <- fire_data %>%
            rename(id = STARFIRE_INCIDENT_ID, datetime = INCIDENT_DATETIME, al_borough = ALARM_BOX_BOROUGH, al_number = ALARM_BOX_NUMBER, 
                   al_location = ALARM_BOX_LOCATION, incident_borough = INCIDENT_BOROUGH, zipcode = ZIPCODE, pol_prec = POLICEPRECINCT,
                   city_con_dist = CITYCOUNCILDISTRICT, comm_dist = COMMUNITYDISTRICT, comm_sc_dist = COMMUNITYSCHOOLDISTRICT, cong_dist = CONGRESSIONALDISTRICT,
                    al_source_desc = ALARM_SOURCE_DESCRIPTION_TX, al_index_desc = ALARM_LEVEL_INDEX_DESCRIPTION, highest_al_level = HIGHEST_ALARM_LEVEL,
                   incident_class = INCIDENT_CLASSIFICATION, incident_class_group = INCIDENT_CLASSIFICATION_GROUP, dispatch_resp_qy = DISPATCH_RESPONSE_SECONDS_QY,
                   first_ass_datetime = FIRST_ASSIGNMENT_DATETIME, first_act_datetime = FIRST_ACTIVATION_DATETIME,  first_on_scene_datetime = FIRST_ON_SCENE_DATETIME,
                   inc_close_datetime = INCIDENT_CLOSE_DATETIME, valid_disp_resp_rime_indc = VALID_DISPATCH_RSPNS_TIME_INDC, valid_incident_resp_time_indc = VALID_INCIDENT_RSPNS_TIME_INDC,
                   inc_resp_sec_qy = INCIDENT_RESPONSE_SECONDS_QY, inc_travel_time_s_qy = INCIDENT_TRAVEL_TM_SECONDS_QY, engines_assigned = ENGINES_ASSIGNED_QUANTITY,
                   ladders_assigned = LADDERS_ASSIGNED_QUANTITY, others_units_assigned = OTHER_UNITS_ASSIGNED_QUANTITY)
```


As we can see from the summary there are many `NA` values, and many predictors that are as characters and not factors. In this step we will convert the characters predictors as factors merging the values that appear less in the dataset, so we do no have many values that have low frequency in our dataset.

In addition we will add he predictor for the `day_number`, a factorial predictor to indicate in the incident day is a week day or not `is_weekend` and a factorial predictor `time_of_day` that indicates the range of time whenever the incident happens, so `Night` (if the hour is between 0 and 6), `Morning`  (if the hour is between 6 and 12), `Afternoon` (if the hour is between 12 and 18), `Evening`  (if the hour is between 18 and 24).

Finally for convenience we convert the datetime that are currently a characters into POSIX type in the following format: `"%m-%d-%Y %H:%M:%S"`


```{r}
# set factorial
fire_data$incident_borough <- as.factor(fire_data$incident_borough)
fire_data$al_borough <- as.factor(fire_data$al_borough)
fire_data$al_source_desc <- as.factor(fire_data$al_source_desc)
fire_data$al_index_desc <- as.factor(fire_data$al_index_desc)
fire_data$highest_al_level <- as.factor(fire_data$highest_al_level)

fire_data$valid_disp_resp_rime_indc <- as.factor(fire_data$valid_disp_resp_rime_indc)
levels(fire_data$valid_disp_resp_rime_indc)<- c("N", "Y")

fire_data$valid_incident_resp_time_indc <- as.factor(fire_data$valid_incident_resp_time_indc)
levels(fire_data$valid_incident_resp_time_indc)<- c("N", "Y")

fire_data$incident_class_group <- as.factor(fire_data$incident_class_group)
fire_data$incident_class <- as.factor(fire_data$incident_class)
```

Here we create the `day_number` predictor and the ``

```{r}
process_fire_datetime <- function(input_df) {

  # Process datetime column
  input_df$datetime <- mdy_hms(input_df$datetime)
  
  # Create new columns for day number,  time of day and is weekend 
  input_df$day_number <- as.factor(day(input_df$datetime))
  
  input_df$time_of_day <- cut(
    hour(input_df$datetime),
    breaks = c(0, 6, 12, 18, 24),
    labels = c("Night", "Morning", "Afternoon", "Evening"),
    include.lowest = TRUE,
    right = TRUE
  )
  
  input_df <- input_df %>%
  mutate(is_weekend = ifelse(weekdays(datetime) %in% c("Saturday", "Sunday"), TRUE, FALSE))
  
  input_df$datetime <- NULL
  
  return(input_df)
}

fire_data <- process_fire_datetime(fire_data)
```


```{r}
# set posix dates
fire_data$first_on_scene_datetime <- as.POSIXct(fire_data$first_on_scene_datetime, format="%m/%d/%Y %H:%M:%S %p")
fire_data$first_ass_datetime <- as.POSIXct(fire_data$first_ass_datetime, format="%m/%d/%Y %H:%M:%S %p")
fire_data$first_act_datetime <- as.POSIXct(fire_data$first_act_datetime, format="%m/%d/%Y %H:%M:%S %p")
fire_data$inc_close_datetime <- as.POSIXct(fire_data$inc_close_datetime, format="%m/%d/%Y %H:%M:%S %p")
```



At this point we merge some possible value from factorial predictors to make the space of possible choice smaller.

Here we merge the following factorial values of `highest_al_level`: `Second Alarm` and `Third Alarm` into `2nd-3rd Alarm`.


```{r}
# highest_al_level
fire_data$highest_alarm_lev_new <- fire_data$highest_al_level
levels(fire_data$highest_alarm_lev_new) <- list(
  "All Hands Working" = "All Hands Working",
  "First Alarm" = "First Alarm", 
  "2nd-3rd Alarm" = c("Second Alarm", "Third Alarm")
)

print(ctable(fire_data$highest_al_level, fire_data$highest_alarm_lev_new), method = 'render')

fire_data$highest_al_level <- fire_data$highest_alarm_lev_new
fire_data$highest_alarm_lev_new <- NULL
```

Here we merge the following factorial values of `al_index_desc`: `Second Alarm`, `Third Alarm`, `7-5 (All Hands Alarm)`, `10-76 & 10-77 Signal (Notification Hi-Rise Fire)` and `10-75 Signal (Request for all hands alarm)` into `Others`.

```{r}
# al_index_desc
fire_data$alarm_level_idx_new <- fire_data$al_index_desc
levels(fire_data$alarm_level_idx_new) <- list(
  "DEFAULT RECORD" = "DEFAULT RECORD",
  "Initial Alarm" = "Initial Alarm", 
  "Others" = c("Second Alarm", "Third Alarm", "7-5 (All Hands Alarm)", 
               "10-76 & 10-77 Signal (Notification Hi-Rise Fire)",
               "10-75 Signal (Request for all hands alarm)")
)

print(ctable(fire_data$al_index_desc, fire_data$alarm_level_idx_new), method = 'render')

fire_data$al_index_desc <- fire_data$alarm_level_idx_new
fire_data$alarm_level_idx_new <- NULL
```

Here we merge the following factorial values of `al_source_desc`: `911`, `911TEXT`, `VERBAL`, `BARS`, `ERS`, `ERS-NC` and `SOL` into `Others`.

```{r}
fire_data$alarm_source_desc_new <- fire_data$al_source_desc
levels(fire_data$alarm_source_desc_new) <- list(
  "PHONE" = "PHONE",
  "EMS" = "EMS",
  "EMS-911" = "EMS-911",
  "CLASS-3" = "CLASS-3",
  "Others" = c("911", "911TEXT", "VERBAL", "BARS", "ERS", "ERS-NC", "SOL")
)

print(ctable(fire_data$al_source_desc, fire_data$alarm_source_desc_new), method = 'render')

fire_data$al_source_desc <- fire_data$alarm_source_desc_new
fire_data$alarm_source_desc_new <- NULL
```
Visualise angain the dataset summary to see the changes.

```{r}
print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```



The next step is to deal with NA value and delete some unusefull predictors.


First of all we saw the possibility that al_boroug and incident_borough are actually the same column.


```{r}
identical(fire_data$al_borough, fire_data$incident_borough)
```
The column al_borough and incident_borough have the same sequence of values, so we can delete one of the two.

```{r}
fire_data <- fire_data %>% select(-c(al_borough))
```



Then we say that all observation in the dataset have the valid_disp_resp_rime_indc equal to N, let's check again and in ffermative case we can delete both columns 

```{r}
summary(fire_data$valid_disp_resp_rime_indc)
```
All our observations have non valid valid_disp_resp_rime_indc so we can delete both the column indicator and the respective column quantity inc_travel_time_s_qy

```{r}
fire_data <- fire_data %>% select(-c(valid_disp_resp_rime_indc, inc_travel_time_s_qy))
```



Now we do a quick check also on the other indindicetor variable

```{r}
summary(fire_data$valid_incident_resp_time_indc)
```
But here we have some observations with valid valid_incident_resp_time_indc, and we will condier only the valid one deleting the one that has a non valid attribute.



Now we want to know how many incident_class are summarized in each incident_class_group.

```{r}
print(ctable(fire_data$incident_class, fire_data$incident_class_group), method = 'render')
```

As we can see from the upper table all the incident_class_group have a unique set of v 

At this point to be more clear we display each main class with each respective sub-class.

```{r}
for (variable in levels(fire_data$incident_class_group)) {
  non_zero_table <- table(subset(fire_data, incident_class_group == variable)$incident_class)
  cat(variable, "\n")
  print(non_zero_table[non_zero_table != 0])
  cat("\n")
}

```


## NA Patterns?

At this point is essential to deal with NA values, trying to find the presence of possible relation with predictors.
First things first let's recap the number of NA values for each columns

```{r}
colSums(is.na(fire_data))
```

TODO:
1. check assigned units
2. check location predictiors
3. check first_on_scene_datetime and inc_resp_sec_qy 




First of all we check if the distribution of invalid `valid_incident_resp_time_indc` is more or less uniform across all the borough.
```{r}
summary(fire_data$valid_incident_resp_time_indc)
```

```{r}
table(fire_data$incident_borough)
```

```{r}
non_valid_inc_resp <- fire_data %>%  filter(valid_incident_resp_time_indc == "N")
  
table(non_valid_inc_resp$incident_borough)
```

```{r}
table(non_valid_inc_resp$incident_borough) / table(fire_data$incident_borough)
```

More or less all the neighborhoods have the same distribution of invalid `valid_inc_resp_time_indc`.






## Data Visaulization


# Let's build some models

But before creating any model have to split the cleaned dataset into *train* and *test*, with 0.8% of the whole dataset for the train set and the remaning 20% for the test set.

```{r}
sample <- sample(c(TRUE, FALSE), nrow(fire_data), replace=TRUE, prob=c(0.8,0.2))
fire_data.train <- fire_data[sample, ]
fire_data.test <- fire_data[!sample, ]
dim(fire_data.train)
dim(fire_data.test)
```



