---
title: "Fire Incident Dispatch Data Analysis"
author: "Zuliani Riccardo"
date: "12/12/2023"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE) #, cache=TRUE
setwd("C:/Users/ricca/Desktop/UNI/Magistrale/Anno3/Statistical_Inference_and_Learning/SIL Projcet/Statistical_Inference_Learning_Project/Fire_Incident_Dispatch_Analysis")

library(nnet)
library(summarytools)

library(dplyr)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(mapview)
library(sf)
library(geojsonio)
library(leaflet) 
library(broom)
library(plotly)
```

# Fire Incident Dispatch Data Analysis
The Fire Incident Dispatch Data file contains data that is generated by the Starfire Computer Aided Dispatch System. The data spans from the time the incident is created in the system to the time the incident is closed in the system. It covers information about the incident as it relates to the assignment of resources and the Fire Departmentâ€™s response to the emergency. To protect personal identifying information in accordance with the Health Insurance Portability and Accountability Act (HIPAA), specific locations of incidents are not included and have been aggregated to a higher level of detail.

In this analysis we have restricted the analysis only on the last 50.000 observations.

### Column descriptions
1. *STARFIRE_INCIDENT_ID*: An incident identifier comprising the 5 character julian date, 4 character alarm box number, 2 character number of incidents at the box so far for the day, 1 character borough code , 4 character sequence number. 
2. *INCIDENT_DATETIME*: The date and time of the incident.
3. *ALARM_BOX_BOROUGH*: The borough of the alarm box.
4. *ALARM_BOX_LOCATION*: The location of the alarm box.
5. *ALARM_BOX*: The alarm box number.
6. *INCIDENT_BOROUGH*: The borough of the incident.
7. *ZIPCODE*: The zip code of the incident.
8. *POLICEPRECINCT*: The police precinct of the incident.
9. *CITYCOUNCILDISTRICT*: The city council district.
10. *COMMUNITYDISTRICT*: The community district.
11. *COMMUNITYSCHOOLDISTRICT*: The community school district.
12. *CONGRESSIONALDISTRICT*: The congressional district.
13. *ALARM_SOURCE_DESCRIPTION_TX*: The description of the alarm source.
14. *ALARM_LEVEL_INDEX_DESCRIPTION*: The alarm level index.
15. *HIGHEST_ALARM_LEVEL*: The highest alarm level.
16. *INCIDENT_CLASSIFICATION*: The incident classification.
17. *INCIDENT_CLASSIFICATION_GROUP*: The incident classification roll up group. (*response*)
18. *DISPATCH_RESPONSE_SECONDS_QY*: The elapsed time in seconds between the incident_datetime and the first_assignment_datetime.
19. *FIRST_ASSIGNMENT_DATETIME*: The date and time of the first unit assignment.
20. *FIRST_ACTIVATION_DATETIME*: The date and time of the first unit acknowledgement of the assignment.
21. *FIRST_ON_SCENE_DATETIME*: The date and time of the first unit at the scene of the incident.
22. *INCIDENT_CLOSE_DATETIME*: The date and time that the incident was closed in the dispatch system.
23. *VALID_DISPATCH_RSPNS_TIME_INDC*: Indicates that the components comprising the generation of the DISPATCH_RESPONSE_SECONDS_QY are valid.
24. *VALID_INCIDENT_RSPNS_TIME_INDC*: Indicates that the components comprising the generation of the INCIDENT_RESPONSE_SECONDS_QY are valid.
25. *INCIDENT_RESPONSE_SECONDS_QY*: The elapsed time in seconds between the incident_datetime and the first_onscene_datetime.
26. *INCIDENT_TRAVEL_TM_SECONDS_QY*: The elapsed time in seconds between the first_assignment_datetime and the first_onscene_datetime.
27. *ENGINES_ASSIGNED_QUANTITY*: The number of engine units assigned to the incident.
28. *LADDERS_ASSIGNED_QUANTITY*: The number of ladder units assigned to the incident.
29. *OTHER_UNITS_ASSIGNED_QUANTITY*: The number of  units that are not engines or ladders that were assigned to the incident.

For this analysis we use as response the *INCIDENT_CLASSIFICATION_GROUP* which contain the main grups of incidents. They are the following one:
1. *Structural Fires*
2. *NonStructural Fires*
3. *NonMedical Emergencies*
4. *NonMedical MFAs*
5. *Medical Emergencies*
6. *Medical MFAs*


The first step is alweays to read the dataset and plot the first 5 observations
```{r, cache=TRUE}
fire_data <- read.csv("datasets/Fire_Incident_Dispatch_Data_last_50k.csv")

head(fire_data)
```

Use `dfSummary` from summarytool in order to have a complete and clear sumamry of the dataset.
```{r}
print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```

Now we rename all the columns in order to be smaller whnever we plot graphs.
```{r}
fire_data <- fire_data %>%
            rename(id = STARFIRE_INCIDENT_ID, datetime = INCIDENT_DATETIME, al_borough = ALARM_BOX_BOROUGH, al_number = ALARM_BOX_NUMBER, 
                   al_location = ALARM_BOX_LOCATION, incident_borough = INCIDENT_BOROUGH, zipcode = ZIPCODE, pol_prec = POLICEPRECINCT,
                   city_con_dist = CITYCOUNCILDISTRICT, comm_dist = COMMUNITYDISTRICT, comm_sc_dist = COMMUNITYSCHOOLDISTRICT, cong_dist = CONGRESSIONALDISTRICT,
                    al_source_desc = ALARM_SOURCE_DESCRIPTION_TX, al_index_desc = ALARM_LEVEL_INDEX_DESCRIPTION, highest_al_level = HIGHEST_ALARM_LEVEL,
                   incident_class = INCIDENT_CLASSIFICATION, incident_class_group = INCIDENT_CLASSIFICATION_GROUP, dispatch_resp_qy = DISPATCH_RESPONSE_SECONDS_QY,
                   first_ass_datetime = FIRST_ASSIGNMENT_DATETIME, first_act_datetime = FIRST_ACTIVATION_DATETIME,  first_on_scene_datetime = FIRST_ON_SCENE_DATETIME,
                   inc_close_datetime = INCIDENT_CLOSE_DATETIME, valid_disp_resp_rime_indc = VALID_DISPATCH_RSPNS_TIME_INDC, valid_incident_resp_time_indc = VALID_INCIDENT_RSPNS_TIME_INDC,
                   inc_resp_sec_qy = INCIDENT_RESPONSE_SECONDS_QY, inc_travel_time_s_qy = INCIDENT_TRAVEL_TM_SECONDS_QY, engines_assigned = ENGINES_ASSIGNED_QUANTITY,
                   ladders_assigned = LADDERS_ASSIGNED_QUANTITY, others_units_assigned = OTHER_UNITS_ASSIGNED_QUANTITY)
```




As we can see from the summary there are many NA values, and many predictors that are as characters and not factors. In this step we will convert the characters predictors as factors merging the values that appear less in the dataset, so we do no have many values that have low frequency in our dataset. Moreover for convenience we convert the datetime that are currently a characters into POSIX type in the following format: "%m-%d-%Y %H:%M:%S"


```{r}
# set factorial
fire_data$incident_borough <- as.factor(fire_data$incident_borough)
fire_data$al_borough <- as.factor(fire_data$al_borough)
fire_data$al_source_desc <- as.factor(fire_data$al_source_desc)
fire_data$al_index_desc <- as.factor(fire_data$al_index_desc)
fire_data$highest_al_level <- as.factor(fire_data$highest_al_level)

fire_data$valid_incident_resp_time_indc <- as.factor(fire_data$valid_incident_resp_time_indc)
levels(fire_data$valid_incident_resp_time_indc)<- c("N", "Y")

fire_data$incident_class_group <- as.factor(fire_data$incident_class_group)
fire_data$incident_class <- as.factor(fire_data$incident_class)

# set posix dates
fire_data$datetime <- as.POSIXct(fire_data$datetime, format="%m-%d-%Y %H:%M:%S %p")
fire_data$first_on_scene_datetime <- as.POSIXct(fire_data$first_on_scene_datetime, format="%m-%d-%Y %H:%M:%S %p")
fire_data$first_ass_datetime <- as.POSIXct(fire_data$first_ass_datetime, format="%m-%d-%Y %H:%M:%S %p")
fire_data$first_act_datetime <- as.POSIXct(fire_data$first_act_datetime, format="%m-%d-%Y %H:%M:%S %p")
fire_data$inc_close_datetime <- as.POSIXct(fire_data$inc_close_datetime, format="%m-%d-%Y %H:%M:%S %p")
```


At this point we merge some possible value from factorial predictors to make the space of possible choice smaller


```{r}
# highest_al_level
fire_data$highest_alarm_lev_new <- fire_data$highest_al_level
levels(fire_data$highest_alarm_lev_new) <- list(
  "All Hands Working" = "All Hands Working",
  "First Alarm" = "First Alarm", 
  "2nd-3rd Alarm" = c("Second Alarm", "Third Alarm")
)

print(ctable(fire_data$highest_al_level, fire_data$highest_alarm_lev_new), method = 'render')

fire_data$highest_al_level <- fire_data$highest_alarm_lev_new
fire_data$highest_alarm_lev_new <- NULL
```

```{r}
# al_index_desc
fire_data$alarm_level_idx_new <- fire_data$al_index_desc
levels(fire_data$alarm_level_idx_new) <- list(
  "DEFAULT RECORD" = "DEFAULT RECORD",
  "Initial Alarm" = "Initial Alarm", 
  "Others" = c("Second Alarm", "Third Alarm", "7-5 (All Hands Alarm)", 
               "10-76 & 10-77 Signal (Notification Hi-Rise Fire)",
               "10-75 Signal (Request for all hands alarm)")
)

print(ctable(fire_data$al_index_desc, fire_data$alarm_level_idx_new), method = 'render')

fire_data$al_index_desc <- fire_data$alarm_level_idx_new
fire_data$alarm_level_idx_new <- NULL
```


```{r}
# al_source_desc
fire_data$alarm_source_desc_new <- fire_data$al_source_desc
levels(fire_data$alarm_source_desc_new) <- list(
  "PHONE" = "PHONE",
  "EMS" = "EMS",
  "EMS-911" = "EMS-911",
  "CLASS-3" = "CLASS-3",
  "Others" = c("911", "911TEXT", "VERBAL", "BARS", "ERS", "ERS-NC", "SOL")
)

print(ctable(fire_data$al_source_desc, fire_data$alarm_source_desc_new), method = 'render')

fire_data$al_source_desc <- fire_data$alarm_source_desc_new
fire_data$alarm_source_desc_new <- NULL
```
Visualise angain the dataset summary to see the changes.

```{r}
print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```









## Check column before deleting them

```{r}
identical(fire_data$ALARM_BOX_BOROUGH, fire_data$INCIDENT_BOROUGH)
```
The column ALARM_BOX_BOROUGH and INCIDENT_BOROUGH have the same sequence of values, so we can delete one of the two

```{r}
fire_data$VALID_DISPATCH_RSPNS_TIME_INDC <- as.factor(fire_data$VALID_DISPATCH_RSPNS_TIME_INDC)
summary(fire_data$VALID_DISPATCH_RSPNS_TIME_IND)
```
All our observations have non valid VALID_DISPATCH_RSPNS_TIME_IND so we can delete both the column indicator and the respective column quantity



```{r}
fire_data$VALID_INCIDENT_RSPNS_TIME_INDC <- as.factor(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
summary(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
```
Whereas here we have some observations with valid VALID_INCIDENT_RSPNS_TIME_INDC, we will delete the one that has a non valid attribute



Let's set some factorials
```{r}
fire_data$INCIDENT_BOROUGH <- as.factor(fire_data$INCIDENT_BOROUGH)
fire_data$ALARM_SOURCE_DESCRIPTION_TX <- as.factor(fire_data$ALARM_SOURCE_DESCRIPTION_TX)
fire_data$ALARM_LEVEL_INDEX_DESCRIPTION <- as.factor(fire_data$ALARM_LEVEL_INDEX_DESCRIPTION)
fire_data$HIGHEST_ALARM_LEVEL <- as.factor(fire_data$HIGHEST_ALARM_LEVEL)

fire_data$VALID_INCIDENT_RSPNS_TIME_INDC <- as.factor(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
levels(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)<- c("N", "Y")

fire_data$INCIDENT_CLASSIFICATION_GROUP <- as.factor(fire_data$INCIDENT_CLASSIFICATION_GROUP)
fire_data$INCIDENT_CLASSIFICATION <- as.factor(fire_data$INCIDENT_CLASSIFICATION)
```



Now we want to know how many INCIDENT_CLASSIFICATION class are summarized in each INCIDENT_CLASSIFICATION_GROUP
```{r}
print(ctable(fire_data$INCIDENT_CLASSIFICATION, fire_data$INCIDENT_CLASSIFICATION_GROUP), method = 'render')
```
As we can see from the upper table all the INCIDENT_CLASSIFICATION_GROUP have a unique set of INCIDENT_CLASSIFICATION 

At this point to be more clear we display each main class with each respective sub-class and then we meke a little description.

```{r}
for (variable in levels(fire_data$INCIDENT_CLASSIFICATION_GROUP)) {
  non_zero_table <- table(subset(fire_data, INCIDENT_CLASSIFICATION_GROUP == variable)$INCIDENT_CLASSIFICATION)
  cat(variable, "\n")
  print(non_zero_table[non_zero_table != 0])
  cat("\n")
}

```



**Medical Emergency**:
1. *Medical - Assist Civilian*




## See if there is a pattern with the NA/invaid values

First of all we check if the distribution of invalid VALID_INCIDENT_RSPNS_TIME_INDC is more or less uniform across all the neighborhoods
```{r}
summary(fire_data$VALID_INCIDENT_RSPNS_TIME_INDC)
```

```{r}
table(fire_data$INCIDENT_BOROUGH)
```

```{r}
non_valid_inc_resp <- subset(fire_data, VALID_INCIDENT_RSPNS_TIME_INDC == "N")
table(non_valid_inc_resp$INCIDENT_BOROUGH)
```

```{r}
table(non_valid_inc_resp$INCIDENT_BOROUGH) / table(fire_data$INCIDENT_BOROUGH)
```

More or less all the neighborhoods have the same distribution of invalid valid_inc_resp_time_indc


Now we want to check some other aspects of the data, for example the NA values of the DISTRICT columns, let's summarize the data again

```{r}
summary(fire_data)
```

```{r}
na_locations <- subset(fire_data, is.na(ZIPCODE) | is.na(POLICEPRECINCT) | is.na(CITYCOUNCILDISTRICT) | is.na(COMMUNITYDISTRICT) |  is.na(COMMUNITYSCHOOLDISTRICT) |  is.na(CONGRESSIONALDISTRICT))
print(dfSummary(na_locations, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```

```{r}
table(na_locations$INCIDENT_BOROUGH) / table(fire_data$INCIDENT_BOROUGH)
```

```{r}
table(na_locations$INCIDENT_CLASSIFICATION_GROUP) / table(fire_data$INCIDENT_CLASSIFICATION_GROUP)
```

This is interesting, we see that about the 43% of the NonMedical MFAs INCIDENT_CLASSIFICATION_GROUP are NA whereas the other classes have lower percentage. We can try to investigate this phenomena.


```{r}
fd_nm_mfa_cl <- table(subset(fire_data, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_CLASSIFICATION)
fd_nm_mfa_bro <- table(subset(fire_data, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_BOROUGH)

fd_nm_mfa_cl <- fd_nm_mfa_cl[fd_nm_mfa_cl != 0]
fd_nm_mfa_cl
```


```{r}
na_nm_mfa_cl <- table(subset(na_locations, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_CLASSIFICATION)
na_nm_mfa_bro <- table(subset(na_locations, INCIDENT_CLASSIFICATION_GROUP == "NonMedical MFAs")$INCIDENT_BOROUGH)

na_nm_mfa_cl <- na_nm_mfa_cl[names(fd_nm_mfa_cl)]
na_nm_mfa_cl
```
Here we can see that the majority of observation that at least one location attributes to NA have a response equal to Non-Medical MFA - ERS



```{r}
na_nm_mfa_cl / fd_nm_mfa_cl
```
So the 97% of all the Non-Medical MFA - ERS observations in the entire dataset have one of the location attribute equal to NA

```{r}
na_nm_mfa_bro / fd_nm_mfa_bro
```
And from here we can see that about the 78% of the observations that are NonMedical - MFAs that have at least one district column attribute to NA are from the RICHMOND / STATEN ISLAND.
Also BRONX has about half of the NonMedical - MFAs observations that have at least one district column to NA.




```{r}
print(summary(subset(fire_data, VALID_INCIDENT_RSPNS_TIME_INDC == "N")$INCIDENT_RESPONSE_SECONDS_QY))
print(summary(fire_data$INCIDENT_RESPONSE_SECONDS_QY))
```
Here we can see that all the observation NA observation to the INCIDENT_RESPONSE_SECONDS_QY has the respective VALID_INCIDENT_RSPNS_TIME_INDC value to N



## Removing all the NA and unuseful columns from the dataset

Remove some columns
```{r}
fire_data = subset(fire_data, select = -c(
  STARFIRE_INCIDENT_ID, ALARM_BOX_BOROUGH, INCIDENT_CLASSIFICATION, ALARM_BOX_LOCATION,
  VALID_DISPATCH_RSPNS_TIME_INDC, DISPATCH_RESPONSE_SECONDS_QY, 
  FIRST_ASSIGNMENT_DATETIME, FIRST_ACTIVATION_DATETIME, FIRST_ON_SCENE_DATETIME, INCIDENT_CLOSE_DATETIME 
))
```


Rename all the columns with a shorter and usable name
```{r}
names(fire_data) <- c("fire_datetime", "AL_loction", "incident_brough", "zip", "Pprecint", "citycouncil_dist", "community_dist", "comm_school_dist", "congressional_dist", "alarm_source_desc", "alarm_level_idx", "highest_alarm_lev", "incident_class", "valid_inc_resp_time_indc", "incident_resp_sec", "incident_travel_time_sec", "engines_assigned", "ladders_assigned", "other_utits_assigned")
names(fire_data)
```

```{r}
# Select the observations with the valid_inc_resp_time_indc set to Y
fire_data <- subset(fire_data, valid_inc_resp_time_indc == "Y")

fire_data <- na.omit(fire_data)

print(dfSummary(fire_data, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```

Remove the VALID_INCIDENT_RSPNS_TIME_INDC column
```{r}
fire_data = subset(fire_data, select = -c(valid_inc_resp_time_indc))
```



## Merging factor

```{r}
# highest_alarm_lev
fire_data$highest_alarm_lev_new <- fire_data$highest_alarm_lev
levels(fire_data$highest_alarm_lev_new) <- list(
  "All Hands Working" = "All Hands Working",
  "First Alarm" = "First Alarm", 
  "2nd-3rd Alarm" = c("Second Alarm", "Third Alarm")
)

print(ctable(fire_data$highest_alarm_lev, fire_data$highest_alarm_lev_new), method = 'render')

fire_data$highest_alarm_lev <- fire_data$highest_alarm_lev_new
fire_data$highest_alarm_lev_new <- NULL
```

```{r}
# alarm_level_idx
fire_data$alarm_level_idx_new <- fire_data$alarm_level_idx
levels(fire_data$alarm_level_idx_new) <- list(
  "DEFAULT RECORD" = "DEFAULT RECORD",
  "Initial Alarm" = "Initial Alarm", 
  "Others" = c("Second Alarm", "Third Alarm", "7-5 (All Hands Alarm)", 
               "10-76 & 10-77 Signal (Notification Hi-Rise Fire)",
               "10-75 Signal (Request for all hands alarm)")
)

print(ctable(fire_data$alarm_level_idx, fire_data$alarm_level_idx_new), method = 'render')

fire_data$alarm_level_idx <- fire_data$alarm_level_idx_new
fire_data$alarm_level_idx_new <- NULL
```


```{r}
# alarm_source_desc
fire_data$alarm_source_desc_new <- fire_data$alarm_source_desc
levels(fire_data$alarm_source_desc_new) <- list(
  "PHONE" = "PHONE",
  "EMS" = "EMS",
  "EMS-911" = "EMS-911",
  "CLASS-3" = "CLASS-3",
  "Others" = c("911", "911TEXT", "VERBAL", "BARS", "ERS", "ERS-NC", "SOL")
)

print(ctable(fire_data$alarm_source_desc, fire_data$alarm_source_desc_new), method = 'render')

fire_data$alarm_source_desc <- fire_data$alarm_source_desc_new
fire_data$alarm_source_desc_new <- NULL
```

Check the distribution of the classes
```{r}
round(summary(fire_data$incident_class) / nrow(fire_data), digits = 4)
```


## Process datetime
Here we extract the date number and the moment in which the fire happened divided into "Night", "Morning", "Afternoon" and "Evening"

```{r}
process_fire_datetime <- function(input_df) {

  # Process datetime column
  input_df$fire_datetime <- mdy_hms(input_df$fire_datetime)
  
  # Create new columns for day number and time of day
  input_df$day_number <- as.factor(day(input_df$fire_datetime))
  input_df$time_of_day <- cut(
    hour(input_df$fire_datetime),
    breaks = c(0, 6, 12, 18, 24),
    labels = c("Night", "Morning", "Afternoon", "Evening"),
    include.lowest = TRUE,
    right = TRUE
  )
  
  input_df$fire_datetime <- NULL
  
  return(input_df)
}

fire_data_new <- process_fire_datetime(fire_data)

print(dfSummary(fire_data_new, 
                varnumbers   = FALSE, 
                valid.col    = FALSE, 
                graph.magnif = 0.76),
                method = 'render')
```


## Train test split
```{r}
sample <- sample(c(TRUE, FALSE), nrow(fire_data_new), replace=TRUE, prob=c(0.8,0.2))
fire_data.train <- fire_data_new[sample, ]
fire_data.test <- fire_data_new[!sample, ]
#fire_data.test <- subset(fire_data.test, select = -incident_class)
dim(fire_data.train)
dim(fire_data.test)
```



Check the distribution of the class in the train set
```{r}
round(summary(fire_data.train$incident_class) / nrow(fire_data.train), digits = 4)
```






## TODO
1. Know the meaning of the incident class -> fatto basta guardare la tabella riassuntiva
2. View if there are some relation within the missing data -> faccio questo domani
3. Start to plot some data to see some relation between some data

## Check if solving the problem as a classification task wrt each main class so 
1. structural and non-structural fire
2. medical and non-medical emergency
3. medical and non-medical MFAs


# Molutinomial Logistic Regression
```{r}
pValue_extract <- function(x){
  z <- summary(x)$coefficients/summary(x)$standard.errors
  # 2-tailed Wald z tests to test significance of coefficients
  p <- (1 - pnorm(abs(z), 0, 1)) * 2
  p
}
```


```{r}
multi.fit1 <- multinom(incident_class ~ ., data = fire_data.train, trace = FALSE)
```

```{r}
table(preds = multi.preds1 <- predict(multi.fit1, newdata = fire_data.test), true = fire_data.test$incident_class)
```

```{r}
multi.fit1$AIC
```
```{r}
mean(multi.preds1 == fire_data.test$incident_class)
```

```{r}
#pValue_extract(multi.fit1)
```




Try a new model with less predictors
```{r}
multi.fit2 <- update(multi.fit1, . ~ . - AL_loction - zip - Pprecint - citycouncil_dist - community_dist - comm_school_dist - congressional_dist - day_number)
multi.fit2$AIC
```

```{r}
table(preds = multi.preds2 <- predict(multi.fit2, newdata = fire_data.test), true = fire_data.test$incident_class)
```


```{r}
mean(multi.preds2 == fire_data.test$incident_class)
```

```{r}
summary(multi.fit2, wald = TRUE)
```

```{r}
#pValue_extract(multi.fit2)
```


## Linear Discriminant Analysis
Now consider linear discriminant analysis:
```{r}
library("MASS")
lda.fit <- lda(formula(multi.fit2), data = fire_data.train)
lda.fit
```
Prediction:
```{r}
lda.preds <- predict(lda.fit, newdata = fire_data.test)
``` 

```{r}
table(preds = lda.preds$class, true = fire_data.test$incident_class)
```
The accuracy of linear discriminant analysis is worse respect to the multinomial logistic regression:
```{r}
mean(lda.preds$class == fire_data.test$incident_class)
```


Now consider quadratic discriminant analysis:



## Naive Bayes
```{r}
library("e1071")
nb.fit <- naiveBayes(formula(multi.fit2), data = fire_data.train)
```
Prediction:
```{r}
nb.preds <- predict(nb.fit, newdata = fire_data.test, type = "class")
``` 

```{r}
table(preds = nb.preds, true = fire_data.test$incident_class)
```
The accuracy of linear discriminant analysis is worse respect to the multinomial logistic regression:
```{r}
mean(nb.preds == fire_data.test$incident_class)
```

## K-Nearest Neighbours
```{r}
x.train <- model.matrix(~ incident_brough + alarm_source_desc + alarm_level_idx + 
    highest_alarm_lev + incident_resp_sec + incident_travel_time_sec + 
    engines_assigned + ladders_assigned + other_utits_assigned + 
    time_of_day, data = fire_data.train)[, -1]
x.test <- model.matrix(~ incident_brough + alarm_source_desc + alarm_level_idx + 
    highest_alarm_lev + incident_resp_sec + incident_travel_time_sec + 
    engines_assigned + ladders_assigned + other_utits_assigned + 
    time_of_day, data = fire_data.test)[, -1]
library("class")
set.seed(98765)
rates <- double(30)
for (i in 1:30) {
  tmp <- knn(train = x.train, test = x.test, cl = fire_data.train$incident_class, k = i)
  rates[i] <- mean(tmp == fire_data.test$incident_class)
}
plot(x = (1:30), y = rates, xlab = "k", ylab = "Accuracy", type = "l")
```

